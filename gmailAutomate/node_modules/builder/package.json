{
  "name": "builder",
  "version": "2.10.1",
  "description": "An NPM-based task runner",
  "repository": {
    "type": "git",
    "url": "https://github.com/FormidableLabs/builder.git"
  },
  "author": {
    "name": "Ryan Roemer",
    "email": "ryan.roemer@formidable.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/FormidableLabs/builder/issues"
  },
  "homepage": "https://github.com/FormidableLabs/builder",
  "scripts": {
    "builder:lint-server": "eslint --color -c .eslintrc-server lib bin",
    "builder:lint-server-test": "eslint --color -c .eslintrc-server-test test",
    "builder:lint": "npm run builder:lint-server && npm run builder:lint-server-test",
    "builder:test": "mocha --opts test/server/mocha.opts test/server/spec",
    "builder:test-cov": "istanbul cover --config .istanbul.server.yml _mocha -- --opts test/server/mocha.opts test/server/spec",
    "builder:check": "npm run builder:lint && npm run builder:test",
    "builder:check-ci": "npm run builder:lint && npm run builder:test-cov"
  },
  "bin": {
    "builder": "bin/builder.js"
  },
  "dependencies": {
    "async": "^1.4.2",
    "chalk": "^1.1.1",
    "js-yaml": "^3.4.3",
    "lodash": "^3.10.1",
    "nopt": "^3.0.6",
    "tree-kill": "^1.0.0"
  },
  "devDependencies": {
    "chai": "^3.4.1",
    "coveralls": "^2.11.4",
    "eslint": "^1.7.3",
    "eslint-config-defaults": "^7.0.1",
    "eslint-plugin-filenames": "^0.1.2",
    "istanbul": "^0.4.1",
    "mocha": "^2.3.4",
    "mock-fs": "^3.7.0",
    "sinon": "^1.17.2",
    "sinon-chai": "^2.8.0"
  },
  "readme": "[![Travis Status][trav_img]][trav_site]\n[![Coverage Status][cov_img]][cov_site]\n\nBuilder\n=======\n\nBuilder takes your `npm` tasks and makes them composable, controllable from\na single point, and flexible.\n\n`npm` is fantastic for controlling tasks (via `scripts`) and general project\nworkflows. But a project-specific `package.json` simply doesn't scale when\nyou're managing many (say 5-50) very similar repositories.\n\n_Enter Builder._ Builder is \"almost\" `npm`, but provides for off-the-shelf\n\"archetypes\" to provide central sets of `package.json` `scripts` tasks, and\n`dependencies` and `devDependencies` for those tasks. The rest of this page will\ndive into the details and machinations of the tool, but first here are a few of\nthe rough goals and motivations behind the project.\n\n* **Single Point of Control**: A way to define a specific set of tasks /\n  configs / etc. for one \"type\" of project. For example, we have an\n  ever-expanding set of related repos for our\n  [Victory](https://github.com/FormidableLabs/?utf8=%E2%9C%93&query=victory)\n  project which all share a nearly-identical dev / prod / build workflow.\n* **Flexibility**: There are a number of meta tools for controlling JavaScript\n  workflows / development lifecycles. However, most are of the \"buy the farm\"\n  nature. This works great when everything is within the workflow but falls\n  apart once you want to be \"just slightly\" different. Builder solves this by\n  allowing fine grain task overriding by name, where the larger composed tasks\n  still stay the same and allow a specific repo's deviation from \"completely off\n  the shelf\" to be painless.\n* **You Can Give Up**: One of the main goals of builder is to remain very\n  close to a basic `npm` workflow. So much so, that we include a section in this\n  guide on how to abandon the use of Builder in a project and revert everything\n  from archetypes back to vanilla `npm` `package.json` `scripts`, `dependencies`\n  and `devDependencies`.\n* **A Few \"Nice to Haves\" Over `npm run <task>`**: Setting aside archetypes and\n  multi-project management, `builder` provides cross-OS compatible helpers for\n  common task running scenarios like concurrent execution (`concurrent`) and\n  spawning the _same_ tasks in parallel with different environment variables\n  (`env`). It also provides useful controls for task retries, buffered output,\n  setup tasks, etc.\n\n## Overview\n\nAt a high level `builder` is a tool for consuming `package.json` `scripts`\ncommands, providing sensible / flexible defaults, and supporting various scenarios\n(\"archetypes\") for your common use cases across multiple projects.\n\nBuilder is not opinionated, although archetypes _are_ and typically dictate\nfile structure, standard configurations, and dev workflows. Builder supports\nthis in an agnostic way, providing essentially the following:\n\n* `NODE_PATH`, `PATH` enhancements and module patterns to run, build, import\n  from archetypes so task dependencies and configurations don't have to be\n  installed directly in a root project.\n* A task runner capable of single tasks (`run`) or multiple concurrent tasks\n  (`concurrent`).\n* An intelligent merging of `package.json` `scripts` tasks.\n\n... and that's about it!\n\n### Usage\n\nTo start using builder, install and save `builder` and any archetypes you\nintend to use. We'll use the [builder-react-component][] archetype as an\nexample.\n\n**Note**: Most archetypes have an `ARCHETYPE` package and parallel\n`ARCHETYPE-dev` npm package. The `ARCHETYPE` package contains _almost_\neverything needed for the archetype (prod dependencies, scripts, etc.) except\nfor the `devDependencies` which the latter `ARCHETYPE-dev` package is solely\nresponsible for bringing in.\n\n#### Global Install\n\nFor ease of use, one option is to globally install `builder` and locally install\narchetypes:\n\n```sh\n$ npm install -g builder\n$ npm install --save builder-react-component\n$ npm install --save-dev builder-react-component-dev\n```\n\nLike a global install of _any_ Node.js meta / task runner tool (e.g., `eslint`,\n`mocha`, `gulp`, `grunt`) doing a global install is painful because:\n\n* You are tied to _just one_ version of the tool for all projects.\n* You must also globally install the tool in CI, on servers, etc.\n\n... so instead, we **strongly recommend** a local install described in the\nnext section!\n\nTo help you keep up with project-specific builder requirements, a globally-installed\n`builder` will detect if a locally-installed version of `builder` is\navailable and switch to that instead:\n\n```sh\n$ /GLOBAL/PATH/TO/builder\n[builder:local-detect] Switched to local builder at: ./node_modules/builder/bin/builder-core.js\n\n... now using local builder! ...\n```\n\n#### Local Install\n\nTo avoid tying yourself to a single, global version of `builder`, the option\nthat we endorse is locally installing both `builder` and archetypes:\n\n```sh\n$ npm install --save builder\n$ npm install --save builder-react-component\n$ npm install --save-dev builder-react-component-dev\n```\n\nHowever, to call `builder` from the command line you will either need to either\naugment `PATH` or call the long form of the command:\n\n##### PATH Augmentation\n\nOur recommended approach is to augment your `PATH` variable with a shell\nconfiguration as follows:\n\n**Mac / Linux**\n\n```sh\n# Safer version, but if you _have_ global installs, those come first.\nexport PATH=\"${PATH}:./node_modules/.bin\"\n\n# (OR) Less safe, but guarantees local node modules come first.\nexport PATH=\"./node_modules/.bin:${PATH}\"\n\n# Check results with:\necho $PATH\n```\n\nTo make these changes **permanent**, add the `export` command to your `.bashrc`\nor analogous shell configuration file.\n\n**Windows**\n\n```sh\n# Safer version, but if you _have_ global installs, those come first.\nset PATH=%PATH%;node_modules\\.bin\n\n# (OR) Less safe, but guarantees local node modules come first.\nset PATH=node_modules\\.bin;%PATH%\n\n# Check results with:\necho %PATH%\n```\n\nTo make these changes **permanent**, please see this multi-OS article on\nchanging the `PATH` variable: https://www.java.com/en/download/help/path.xml\n(the article is targeted for a Java executable, but it's analogous to our\nsituation). You'll want to paste in `;node_modules\\.bin` at the end _or_\n`node_modules\\.bin;` at the beginning of the PATH field in the gui. If there\nis no existing `PATH` then add a user entry with `node_modules\\.bin` as a value.\n(It is unlikely to be empty because an `npm` installation on Windows sets the\nuser `PATH` analogously.)\n\n##### Full Path Invocation\n\nOr you can run the complete path to the builder script with:\n\n**Mac / Linux**\n\n```sh\nnode_modules/.bin/builder <action> <task>\n```\n\n**Windows**\n\n```sh\nnode_modules\\.bin\\builder <action> <task>\n```\n\n#### Configuration\n\nAfter `builder` is available, you can edit `.builderrc` like:\n\n```yaml\n---\narchetypes:\n  - builder-react-component\n```\n\nto bind archetypes.\n\n... and from here you are set for `builder`-controlled meta goodness!\n\n#### Builder Actions\n\nDisplay general or command-specific help (which shows available specific flags).\n\n```sh\n$ builder [-h|--help|help]\n$ builder help <action>\n$ builder help <archetype>\n```\n\nRun `builder help <action>` for all available options. Version information is\navailable with:\n\n```sh\n$ builder [-v|--version]\n```\n\nLet's dive a little deeper into the main builder actions:\n\n##### builder run\n\nRun a single task from `script`. Analogous to `npm run <task>`\n\n```sh\n$ builder run <task>\n```\n\nFlags:\n\n* `--tries`: Number of times to attempt a task (default: `1`)\n* `--setup`: Single task to run for the entirety of `<action>`\n* `--quiet`: Silence logging\n* `--log-level`: Level to log at (`info`, `warn`, `error`, `none`)\n* `--unlimited-buffer`: Unlimited shell output buffer.\n* `--expand-archetype`: Expand `node_modules/<archetype>` with full path (default: `false`)\n* `--builderrc`: Path to builder config file (default: `.builderrc`)\n\n##### builder concurrent\n\nRun multiple tasks from `script` concurrently. Roughly analogous to\n`npm run <task1> & npm run <task2> & npm run <task3>`, but kills all processes on\nfirst non-zero exit (which makes it suitable for test tasks), unless `--no-bail`\nis provided.\n\n```sh\n$ builder concurrent <task1> <task2> <task3>\n```\n\nFlags:\n\n* `--tries`: Number of times to attempt a task (default: `1`)\n* `--setup`: Single task to run for the entirety of `<action>`\n* `--queue`: Number of concurrent processes to run (default: unlimited - `0|null`)\n* `--[no-]buffer`: Buffer output until process end (default: `false`)\n* `--[no-]bail`: End all processes after the first failure (default: `true`)\n* `--quiet`: Silence logging\n* `--log-level`: Level to log at (`info`, `warn`, `error`, `none`)\n* `--unlimited-buffer`: Unlimited shell output buffer.\n* `--expand-archetype`: Expand `node_modules/<archetype>` with full path (default: `false`)\n* `--builderrc`: Path to builder config file (default: `.builderrc`)\n\nNote that `tries` will retry _individual_ tasks that are part of the concurrent\ngroup, not the group itself. So, if `builder concurrent --tries=3 foo bar baz`\nis run and bar fails twice, then only `bar` would be retried. `foo` and `baz`\nwould only execute _once_ if successful.\n\n##### builder envs\n\nRun a single task from `script` concurrently for each item in an array of different\nenvironment variables. Roughly analogous to:\n\n```sh\n$ FOO=VAL1 npm run <task> & FOO=VAL2 npm run <task> & FOO=VAL3 npm run <task>\n```\n\n... but kills all processes on first non-zero exit (which makes it suitable for\ntest tasks), unless `--no-bail` is provided. Usage:\n\n```sh\n$ builder envs <task> <json-array>\n$ builder envs <task> --envs-path=<path-to-json-file>\n```\n\nExamples:\n\n```sh\n$ builder envs <task> '[{ \"FOO\": \"VAL1\" }, { \"FOO\": \"VAL2\" }, { \"FOO\": \"VAL3\" }]'\n$ builder envs <task> '[{ \"FOO\": \"VAL1\", \"BAR\": \"VAL2\" }, { \"FOO\": \"VAL3\" }]'\n```\n\nFlags:\n\n* `--tries`: Number of times to attempt a task (default: `1`)\n* `--setup`: Single task to run for the entirety of `<action>`\n* `--queue`: Number of concurrent processes to run (default: unlimited - `0|null`)\n* `--[no-]buffer`: Buffer output until process end (default: `false`)\n* `--[no-]bail`: End all processes after the first failure (default: `true`)\n* `--envs-path`: Path to JSON env variable array file (default: `null`)\n* `--quiet`: Silence logging\n* `--log-level`: Level to log at (`info`, `warn`, `error`, `none`)\n* `--unlimited-buffer`: Unlimited shell output buffer.\n* `--expand-archetype`: Expand `node_modules/<archetype>` with full path (default: `false`)\n* `--builderrc`: Path to builder config file (default: `.builderrc`)\n\n_Note_: The environments JSON array will overwrite **existing** values in the\nenvironment.\n\n###### Custom Flags\n\nJust like [`npm run <task> [-- <args>...]`](https://docs.npmjs.com/cli/run-script),\nflags after a ` -- ` token in a builder task or from the command line are passed\non to the underlying tasks. This is slightly more complicated for builder in\nthat composed tasks pass on the flags _all the way down_. So, for tasks like:\n\n```js\n\"scripts\": {\n  \"down\": \"echo down\",\n  \"way\": \"builder run down -- --way\",\n  \"the\": \"builder run way -- --the\",\n  \"all\": \"builder run the -- --all\"\n}\n```\n\nWe can run some basics (alone and with a user-added flag):\n\n```sh\n$ builder run down\ndown\n\n$ builder run down -- --my-custom-flag\ndown --my-custom-flag\n```\n\nIf we run the composed commands, the `--` flags are accumulated:\n\n```sh\n$ builder run all\ndown --way --the --all\n\n$ builder run all -- --my-custom-flag\ndown --way --the --all --my-custom-flag\n```\n\nThe rough heuristic here is if we have custom arguments:\n\n1. If a `builder <action>` command, pass through using builder-specific\n   environment variables. (Builder uses `_BUILDER_ARGS_CUSTOM_FLAGS`).\n2. If a non-`builder` command, then append without ` -- ` token.\n\n###### Expanding the Archetype Path\n\nBuilder tasks often refer to configuration files in the archetype itself like:\n\n```js\n\"postinstall\": \"webpack --bail --config node_modules/<archetype>/config/webpack/webpack.config.js\",\n```\n\nIn npm v2 this wasn't a problem because dependencies were usually nested. In\nnpm v3, this all changes with aggressive\n[flattening](https://docs.npmjs.com/cli/dedupe) of dependencies. With flattened\ndependencies, the chance that the archetype and its dependencies no longer have\na predictable contained structure increases.\n\nThus, commands like the above succeed if the installation ends up like:\n\n```\nnode_modules/\n  <a module>/\n    node_modules/\n      <archetype>/\n        node_modules/\n          webpack/\n```\n\nIf npm flattens the tree like:\n\n```\nnode_modules/\n  <a module>/\n  <archetype>/\n  webpack/\n```\n\nThen `builder` can still find `webpack` due to its `PATH` and `NODE_PATH`\nmutations. But an issue arises with something like a `postinstall` step after\nthis flattening in that the current working directory of the process will be\n`PATH/TO/node_modules/<a module>/`, which in this flattened scenario would\n**not** find the file:\n\n```\nnode_modules/<archetype>/config/webpack/webpack.config.js\n```\n\nbecause relative to `node_modules/<a module>/` it is now at:\n\n```\n../<archetype>/config/webpack/webpack.config.js\n```\n\nTo address this problem `builder` has an `--expand-archetype` flag that will\nreplace an occurrence of the specific `node_modules/<archetype>` in one of the\narchetype commands with the _full path_ to the archetype, to guarantee\nreferenced files are correctly available.\n\nThe basic heuristic of things to replace is:\n\n* `^node_modules/<archetype>`: Token is very first string.\n* `[\\s\\t]node_modules/<archetype>`: Whitespace before token.\n* `['\"]node_modules/<archetype>`: Quotes before token.\n    * _Note_ that the path coming back from the underlying\n     `require.resolve(module)` will likely be escaped, so things like\n     whitespace in a path + quotes around it may not expand correctly.\n\nSome notes:\n\n* The only real scenario you'll need this is for a module that needs to run\n  a `postinstall` or something as part of an install in a larger project.\n  Root git clone projects controlled by an archetype should work just fine\n  because the archetype will be predictably located at:\n  `node_modules/<archetype>`\n* The `--expand-archetype` flag gets propagated down to all composed `builder`\n  commands internally.\n* The `--expand-archetype` only expands the specific archetype string for its\n  **own** commands and not those in the root projects or other archetypes.\n* The replacement assumes you are using `/` forward slash characters which\n  are the recommended cross-platform way to construct file paths (even on\n  windows).\n* The replacement only replaces at the _start_ of a command string or after\n  whitespace. This means it _won't_ replace `../node_modules/<archetype>` or\n  even `./node_modules/<archetype>`. (In the last case, just omit the `./`\n  in front of a path -- it's a great habit to pick up as `./` breaks on Windows\n  and omitting `./` works on all platforms!)\n\n## Tasks\n\nThe underlying concept here is that `builder` `script` commands simply _are_\nnpm-friendly `package.json` `script` commands. Pretty much anything that you\ncan execute with `npm run <task>` can be executed with `builder run <task>`.\n\nBuilder can run 1+ tasks based out of `package.json` `scripts`. For a basic\nscenario like:\n\n```js\n{\n  \"scripts\": {\n    \"foo\": \"echo FOO\",\n    \"bar\": \"echo BAR\"\n  }\n}\n```\n\nBuilder can run these tasks individually:\n\n```sh\n$ builder run foo\n$ builder run bar\n```\n\nSequentially via `||` or `&&` shell helpers:\n\n```sh\n$ builder run foo && builder run bar\n```\n\nConcurrently via the Builder built-in `concurrent` command:\n\n```sh\n$ builder concurrent foo bar\n```\n\nWith `concurrent`, all tasks continue running until they all complete _or_\nany task exits with a non-zero exit code, in which case all still alive tasks\nare killed and the Builder process exits with the error code.\n\n\n## npm Config\n\n`builder` supports `package.json` `config` properties the same way that `npm`\ndoes, with slight enhancements in consideration of multiple `package.json`'s\nin play.\n\n### `npm` Config Overview\n\nAs a refresher, `npm` utilizes the `config` field of `package.json` to make\n\"per-package\" environment variables to `scripts` tasks. For example, if you\nhave:\n\n```js\n{\n  \"config\": {\n    \"my_name\": \"Bob\"\n  },\n  \"scripts\": {\n    \"get-name\": \"echo Hello, ${npm_package_config_my_name}.\"\n  }\n}\n```\n\nand ran:\n\n```sh\n$ npm run get-name\nHello, Bob.\n```\n\nMore documentation about how `npm` does per-package configuration is at:\n\n* https://docs.npmjs.com/files/package.json#config\n* https://docs.npmjs.com/misc/config#per-package-config-settings\n\n\n### Builder Configs\n\nIn `builder`, for a single `package.json` this works essentially the same in\nthe above example.\n\n```sh\n$ builder run get-name\nHello, Bob.\n```\n\nHowever, `builder` has the added complexity of adding in `config` variables\nfrom archetypes and the environment. So the basic resolution order for a\nconfig environment variable is:\n\n1. Look to `npm_package_config_<VAR_NAME>=<VAR_VAL>` on command line.\n2. If not set, then use `<root>/package.json:config:<VAR_NAME>` value.\n3. If not set, then use `<archetype>/package.json:config:<VAR_NAME>` value.\n\nSo, let's dive in to a slightly more complex example:\n\n```js\n// <archetype>/package.json\n{\n  \"config\": {\n    \"my_name\": \"ARCH BOB\"\n  },\n  \"scripts\": {\n    \"get-name\": \"echo Hello, ${npm_package_config_my_name}.\"\n  }\n}\n\n// <root>/package.json\n{\n  \"config\": {\n    \"my_name\": \"ROOT JANE\"\n  }\n}\n```\n\nWhen we run the `builder` command, the `<root>` value overrides:\n\n```sh\n$ builder run get-name\nHello, ROOT JANE.\n```\n\nWe can inject a command line flag to override even this value:\n\n```sh\n$ npm_package_config_my_name=\"CLI JOE\" builder run get-name\nHello, CLI JOE.\n```\n\n_Note_ that the ability to override via the process environment is unique\nto `builder` and not available in real `npm`.\n\n### Config Notes\n\n#### Tip - Use String Values\n\nAlthough `config` properties can be something like:\n\n```js\n\"config\": {\n  \"enabled\": true\n}\n```\n\nWe strongly recommend that you always set _strings_ like:\n\n```js\n\"config\": {\n  \"enabled\": \"true\"\n}\n```\n\nAnd deal just with _string values_ in your tasks, and files. The reasoning here\nis that when overriding values from the command line, the values will always\nbe strings, which has a potential for messy, hard-to-diagnose bugs if the\noverridden value is not also a string.\n\n#### npmrc Configuration\n\n`npm` has additional functionality for `config` values that are **not**\npresently supported, such as issuing commands like\n`npm config set <pkg-name>:my_name Bill` that store values in `~/.npmrc` and\nthen override the `package.json` values at execution time. We _may_ extend\nsupport for this as well, but not at the present.\n\n#### Command Line Environment Variables\n\n`npm` does **not** support overriding `config` environment variables from the\nactual environment. So doing something in our original example like:\n\n```sh\n$ npm_package_config_my_name=George npm run get-name\nHello, Bob.\n```\n\nIn fact, npm will refuse to even add environment variables starting with\n`npm_package_config` to the `npm run` environment. E.g.\n\n```js\n{\n  \"config\": {},\n  \"scripts\": {\n    \"get-npm-val\": \"echo NPM VAR: ${npm_package_config_var}\",\n    \"get-env-val\": \"echo ENV VAR: ${env_var}\"\n  }\n}\n```\n\nThe `npm` config variable doesn't make it through:\n\n```sh\n$ npm_package_config_var=SET npm run get-npm-val\nNPM VAR:\n```\n\nWhile a normal environment variable will:\n\n```sh\n$ env_var=SET npm run get-env-val\nENV VAR: SET\n```\n\nBy contrast, `builder` _does_ pass through environment variables already\nexisting on the command line, and moreover those overrides takes precedence over\nthe root and archetype package.json values. Those same examples with `builder`\nshow that the environment variables _do_ make it through:\n\n```sh\n$ npm_package_config_var=SET builder run get-npm-val\nNPM VAR: SET\n\n$ env_var=SET builder run get-env-val\nENV VAR: SET\n```\n\nThings are a little more complex when using with `builder envs`, but the\nrough rule is that the environment JSON array wins when specified, otherwise\nthe existing environment is used:\n\n```sh\n$ npm_package_config_var=CLI builder envs get-npm-val --queue=1 \\\n  '[{}, {\"npm_package_config_var\":\"This Overrides\"}]'\nNPM VAR: CLI\nNPM VAR: This Overrides\n```\n\n## Archetypes\n\nArchetypes deal with common scenarios for your projects. Like:\n\n* [builder-react-component][]: A React component\n* A React application server\n* A Chai / jQuery / VanillaJS widget\n\nArchetypes typically provide:\n\n* A `package.json` with `builder`-friendly `script` tasks.\n* Dependencies and dev dependencies for all of the archetype `script` tasks.\n* Configuration files for all `script` tasks.\n\nIn most cases, you won't need to override anything. But, if you do, pick the\nmost granular `scripts` command in the archetype you need to override and\ndefine _just that_ in your project's `package.json` `script` section. Copy\nany configuration files that you need to tweak and re-define the command.\n\n### Task Resolution\n\nThe easiest bet is to just have _one_ archetype per project. But, multiple are\nsupported. In terms of `scripts` tasks, we end up with the following example:\n\n```\nROOT/package.json\nROOT/node_modules/ARCHETYPE_ONE/package.json\nROOT/node_modules/ARCHETYPE_TWO/package.json\n```\n\nSay we have a `.builderrc` like:\n\n```yaml\n---\narchetypes:\n  - ARCHETYPE_ONE\n  - ARCHETYPE_TWO\n```\n\nThe resolution order for a `script` task (say, `foo`) present in all three\n`package.json`'s would be the following:\n\n* Look through `ROOT/package.json` then the configured archetypes in _reverse_\n  order: `ARCHETYPE_TWO/package.json`, then `ARCHETYPE_ONE/package.json` for\n  a matching task `foo`\n* If found `foo`, check if it is a \"pass-through\" task, which means it delegates\n  to a later instance -- basically `\"foo\": \"builder run foo\"`. If so, then look\n  to next instance of task found in order above.\n\n### Special Archetype Tasks\n\nArchetypes use conventional `scripts` task names, except for the following\nspecial cases:\n\n* `\"npm:postinstall\"`\n* `\"npm:preversion\"`\n* `\"npm:version\"`\n* `\"npm:test\"`\n\nThese tasks are specifically actionable during the `npm` lifecycle, and\nconsequently, the archetype mostly ignores those for installation by default,\noffering them up for actual use in _your_ project.\n\nWe strongly recommend entirely\n[avoiding npm lifecycle task names](#avoid-npm-lifecycle-commands)\nin your archetype `package.json` files. So, instead of having:\n\n```js\n// <archetype>/package.json\n// Bad\n\"test\": \"builder concurrent --buffer test-frontend test-backend\"\n```\n\nWe recommend something like:\n\n```js\n// <archetype>/package.json\n// Good / OK\n\"npm:test\": \"builder run test-all\",\n\"test-all\": \"builder concurrent --buffer test-frontend test-backend\"\n\n// Also OK\n\"npm:test\": \"builder concurrent --buffer test-frontend test-backend\"\n```\n\nand then in your `<root>/package.json` using the _real_ lifecycle task name.\n\n```js\n\"test\": \"builder run npm:test\"\n```\n\n### Creating an Archetype\n\nMoving common tasks into an archetype is fairly straightforward and requires\njust a few tweaks to the paths defined in configuration and scripts in order\nto work correctly.\n\n#### Initializing a Project\n\nAn archetype is simply a standard npm module with a valid `package.json`. To set\nup a new archetype from scratch, make a directory for your new archetype,\ninitialize `npm` and link it for ease of development.\n\n```sh\n$ cd path/to/new/archetype\n$ npm init\n$ npm link\n```\n\nFrom your consuming project, you can now link to the archetype directly for ease\nof development after including it in your `dependencies` and creating a\n`.builderrc` as outlined above in [configuration](#configuration).\n\n```sh\n$ cd path/to/consuming/project\n$ npm link new-archetype-name\n```\n\n#### Managing the `dev` Archetype\n\nBecause `builder` archetypes are included as simple npm modules, two separate\nnpm modules are required for archetypes: one for normal dependencies and one for\ndev dependencies. Whereas in a non-builder-archetype project you'd specify dev\ndependencies in `devDependencies`, with `builder` all dev dependencies must be\nregular `dependencies` on a separate dev npm module.\n\n`builder` is designed so that when defining which archetypes to use in a\nconsuming project's `.builderrc`, `builder` will look for two modules, one named\nappropriately in `dependencies` (ex: `my-archetype`) and one in\n`devDependencies` but with `-dev` appended to the name (ex: `my-archetype-dev`).\n\nTo help with managing these while building a builder archetype, install\n[`builder-support`](https://github.com/FormidableLabs/builder-support)\nto create and manage a `dev/` directory within your archetype project with it's\nown `package.json` which can be published as a separate npm module.\n`builder-support` will not only create a `dev/package.json` with an appropriate\npackage name, but will also keep all the other information from your archetype's\nprimary `package.json` up to date as well as keep `README.md` and `.gitignore`\nin parity for hosting the project as a separate npm module.\n\nGet started by installing and running `builder-support gen-dev`:\n\n```sh\n$ npm install builder-support --save-dev\n$ ./node_modules/.bin/builder-support gen-dev\n```\n\n_TIP: Create a task called `\"builder:gen-dev\": \"builder-support gen-dev\"` in\nyour archetype to avoid having to type out the full path each time you update\nyour project's details._\n\nFor ease of development, `npm link` the dev dependency separately:\n\n```sh\n$ cd dev\n$ npm link\n```\n\nThen from your consuming project, you can link to the dev package.\n\n```sh\n$ cd path/to/consuming/project\n$ npm link new-archetype-name-dev\n```\n\nRead the [`builder-support` docs](https://github.com/FormidableLabs/builder-support)\nto learn more about how dev archetypes are easily managed with\n`builder-support gen-dev`.\n\n#### Node Require Resolution and Module Pattern\n\nAs a background primer, whenever a file has a `require(\"lib-name\")` in it, Node\nperforms the following check for `/path/to/ultimate/file.js`:\n\n```\n/path/to/ultimate/node_modules/lib-name\n/path/to/node_modules/lib-name\n/path/node_modules/lib-name\n/node_modules/lib-name\n```\n\nAfter this, Node then checks for `NODE_PATH` for additional paths to search.\nThis presents a potentially awkward pattern when combined with npm\ndeduplication / flattening for say a file like:\n`<root>/node_modules/<archetype>/config/my-config.js` that requires\n`lib-name@right-version` as follows:\n\nNode modules layout:\n\n```\n<root>/\n  node_modules/\n    lib-name@wrong-version\n    <archetype>/\n      config/my-config.js         // require(\"lib-name\");\n    <archetype-dev>/\n      node_modules/\n        lib-name@right-version\n```\n\nThis unfortunately means that the search path for `require(\"lib-name\")` is:\n\n```\n# From file path priority resolution\n<root>/node_modules/<archetype>/config/node_modules\n<root>/node_modules/<archetype>/node_modules\n<root>/node_modules/node_modules\n<root>/node_modules                                   // Matches `lib-name@wrong-version`!!!\n\n# Now, from `NODE_PATH`\n<root>/node_modules/<archetype>/node_modules\n<root>/node_modules/<archetype-dev>/node_modules      // Too late for `right-version`.\n```\n\n##### The Module Pattern\n\nTo remedy this situation, we encourage a very simple pattern to have Node.js\n`require`'s start from the dev archetype when appropriate by adding a one-line\nfile to the dev archetype: `<archetype-dev>/require.js`\n\n```js\n// Contents of <archetype-dev>/require.js\nmodule.exports = require;\n```\n\nBy exporting the `require` from the dev archetype, the resolution starts in the\ndev archetype and thus ensures the dev archetype \"wins\" for the archetype tasks.\nThus in any archetype files that do a `require`, simply switch to:\n\n```js\nvar mod = require(\"<archetype-dev>/require\")(\"lib-name\");             // Module\nvar modPath = require(\"<archetype-dev>/require\").resolve(\"lib-name\"); // Module path\n```\n\nAnd the dependency from the dev archetype is guaranteed to \"win\" no matter what\nhappens with actual module layout from npm installation.\n\n_Note_ that because a file from within the normal `<archetype>` will naturally\nsearch `<archetype>/node_modules` before hitting `<root>/node_modules` you do\nnot need to use this `require` pattern for normal archetype dependencies in\narchetype Node.js files.\n\nNode.js files in the normal production archetype do not need a\n`<archetype>/require.js` file akin to the dev archetype because\n`<archetype>/node_modules` is already at the top of the require search path.\nHowever, some projects may wish to have an archetype control _and provide_\napplication dependencies and dev dependencies, which we discuss in the\n[next section](#application-vs-archetype-dependencies)\n\n###### ES.next Imports and The Module Pattern\n\nThe module pattern works great for any `require()`-based CommoneJS code.\nUnfortunately, when using babel and ES.next imports like:\n\n```js\nimport _ from \"lodash\";\n```\n\nThe module pattern is _not_ available because the actual `require(\"lodash\")`\nstatement spit out during transpilation is not directly accessible to the\ndeveloper.\n\nWe have [ticket #111](https://github.com/FormidableLabs/builder/issues/111) out\nto write a babel plugin to make the module pattern semantics available during\nbabel transpilation as well.\n\n#### Application vs. Archetype Dependencies\n\nOut of the box `builder` does not manage application dependencies, instead\nmanaging dependencies only for builder _workflows_ and _tasks_, e.g. things\nstarting with the `builder` command.\n\nMost notably, this means that if your _application_ code includes a dependency\nlike `lodash`:\n\n```js\n// <root>/src/index.js\nvar _ = require(\"lodash\");\n\nmodule.exports = _.camelCase(\"Hi There\");\n```\n\nand the root project is consumed by _anything besides a `builder` command_,\nthen it **must** have a dependency like:\n\n```js\n// <root>/package.json\n\"dependencies\": {\n  \"lodash\": \"^4.2.1\"\n}\n```\n\nHowever, if you want to use builder to _also_ manage application dependencies,\nthen you can follow [the module pattern](#the-module-pattern) and provide an\n`<archetype>/require.js` file consisting of:\n\n```js\n// Contents of <archetype>/require.js\nmodule.exports = require;\n```\n\nThe root project could then require code like:\n\n\n```js\nvar modFromProd = require(\"<archetype>/require\")(\"lib-name\");               // Module\nvar pathFromProd = require(\"<archetype>/require\").resolve(\"lib-name\");      // Module path\nvar modFromDev = require(\"<archetype-dev>/require\")(\"lib-name\");            // Module\nvar pathFromDev = require(\"<archetype-dev>/require\").resolve(\"lib-name\");   // Module path\n```\n\nUsing the above pattern, `<archetype>` or `<archetype-dev>` dependencies would\noverride `<root>/node_modules` dependencies reliably and irrespective of npm\nflattening.\n\nSo, turning back to our original example, we could utilize archetype\ndependencies by refactoring to something like:\n\n\n```js\n// <root>/src/index.js\nvar _ = require(\"<archetype>/require\")(\"lodash\");\n\nmodule.exports = _.camelCase(\"Hi There\");\n```\n\nand dev code like:\n\n\n```js\n// <root>/test/index.js\nvar _ = require(\"<archetype-dev>/require\")(\"lodash\");\n\nmodule.exports = _.camelCase(\"Hi There\");\n```\n\nafter which you would _not_ need a `lodash` dependency in `root/package.json`.\n\n#### Moving `dependencies` and `scripts` to a New Archetype\n\nOnce everything is configured and `npm link`'d, it should be easy to move\nscripts to your archetype and quickly test them out from a consuming project.\n\n##### Moving `dependencies` and `devDependencies` from an Existing `package.json`\n\n* copy `dependencies` to `package.json` `dependencies`.\n* copy `devDependencies` to `dev/package.json` `dependencies`.\n\n_Note_ that you should only copy `dependencies` from `<root>/package.json` to\n`<archetype>/package.json` that are needed within the archetype itself for:\n\n* Execution of a script. (E.g., the `istanbul` script).\n* Required by a configuration file in the archetype. (E.g., `webpack` if a\n  webpack configuration calls `require(\"webpack\")`).\n\nYou can then remove any dependencies _only_ used by the `scripts` tasks that\nyou have moved to the archetype. However, take care to\n[not remove real application dependencies](#application-vs-archetype-dependencies)\nunless you are using a module pattern to provide\n[application dependencies](#application-dependencies).\n\n\n##### Moving `scripts` and Config Files\n\nAll scripts defined in archetypes will be run from the root of the project\nconsuming the archetype. This means you have to change all paths in your scripts\nto reference their new location within the archetype.\n\nAn example script and config you may be moving to an archetype would look like:\n\n```js\n\"test-server-unit\": \"mocha --opts test/server/mocha.opts test/server/spec\"\n```\n\nWhen moving this script to an archetype, we'd also move the config from\n`test/server/mocha.opts` within the original project to within the\narchetype such as `config/mocha/server/mocha.opts`.\n\nFor this example script, we'd need to update the path to `mocha.opts` as so:\n\n```js\n\"test-server-unit\": \"mocha --opts node_modules/new-archetype-name/config/mocha/server/mocha.opts test/server/spec\"\n```\n\nAny paths that reference files expected in the consuming app (in this example\n`test/server/spec`) do not need to change.\n\n##### Updating Path and Module References in Config Files\n\nAny JavaScript files run from within an archetype (such as config files) require\na few changes related to paths now that the files are being run from within\nan npm module. This includes all `require()` calls referencing npm modules and\nall paths to files that aren't relative.\n\nFor example, `karma.conf.js`:\n\n```js\nmodule.exports = function (config) {\n  require(\"./karma.conf.dev\")(config);\n\n  config.set({\n    preprocessors: {\n      \"test/client/main.js\": [\"webpack\"]\n    },\n    files: [\n      \"sinon/pkg/sinon\",\n      \"test/client/main.js\"\n    ],\n  });\n};\n```\n\nAll non-relative paths to files and npm modules need to be full paths, even ones\nnot in the archetype directory. For files expected to be in the consuming\nproject, this can be achieved by prepending `process.cwd()` to all paths. For\nnpm modules, full paths can be achieved by using\n[`require.resolve()`](https://nodejs.org/api/globals.html#globals_require_resolve).\n\nAn updated config might look like:\n\n```js\nvar path = require(\"path\");\nvar ROOT = process.cwd();\nvar MAIN_PATH = path.join(ROOT, \"test/client/main.js\");\n\nmodule.exports = function (config) {\n  require(\"./karma.conf.dev\")(config);\n\n  config.set({\n    preprocessors: {\n      [MAIN_PATH]: [\"webpack\"]\n    },\n    files: [\n      require.resolve(\"sinon/pkg/sinon\"),                             // Normal archetype\n      require(\"<archetype-dev>/require\").resolve(\"sinon/pkg/sinon\"),  // Dev archetype\n      MAIN_PATH\n    ],\n  });\n};\n```\n\n#### Example `builder` Archetype Project Structure\n\n```\n.\n├── CONTRIBUTING.md\n├── HISTORY.md\n├── LICENSE.txt\n├── README.md\n├── config\n│   ├── eslint\n│   ├── karma\n│   ├── mocha\n│   │   ├── func\n│   │   │   ├── mocha.dev.opts\n│   │   │   └── mocha.opts\n│   │   └── server\n│   │       └── mocha.opts\n│   └── webpack\n│       ├── webpack.config.coverage.js\n│       ├── webpack.config.dev.js\n│       ├── webpack.config.hot.js\n│       ├── webpack.config.js\n│       └── webpack.config.test.js\n├── dev\n│   └── package.json\n│   └── require.js\n└── package.json\n```\n\n## Tips, Tricks, & Notes\n\n### PATH, NODE_PATH Resolution\n\nBuilder uses some magic to enhance `PATH` and `NODE_PATH` to look in the\ninstalled modules of builder archetypes and in the root of your project (per\nnormal). We mutate both of these environment variables to resolve in the\nfollowing order:\n\n`PATH`:\n\n1. `<cwd>/node_modules/<archetype>/.bin`\n2. `<cwd>/node_modules/<archetype-dev>/.bin`\n3. `<cwd>/node_modules/.bin`\n4. Existing `PATH`\n\n`require` + `NODE_PATH`: For `file.js` with a `require`\n\n1. `/PATH/TO/file.js` (all sub directories + `node_modules` going down the tree)\n2. `<cwd>/node_modules/<archetype>/node_modules`\n3. `<cwd>/node_modules/<archetype-dev>/node_modules`\n4. `<cwd>/node_modules`\n5. Existing `NODE_PATH`\n\nThe order of resolution doesn't often come up, but can sometimes be a factor\nin diagnosing archetype issues and script / file paths, especially when using\n`npm` v3.\n\n### Alternative to `npm link`\n\nIn some cases, `npm link` can interfere with the order of resolution. If you\nrun into resolution problems, you can develop locally with the\nfollowing in your consuming project's `package.json` as an alternative to `npm link`:\n\n```json\n{\n  \"dependencies\": {\n    \"YOUR_ARCHETYPE_NAME\": \"file:../YOUR_ARCHETYPE_REPO\"\n  },\n  \"devDependencies\": {\n    \"YOUR_ARCHETYPE_NAME_dev\": \"file:../YOUR_ARCHETYPE_REPO/dev\"\n  }\n}\n```\n\n### Project Root\n\nThe enhancements to `NODE_PATH` that `builder` performs can throw tools /\nlibraries for a loop. Generally speaking, we recommend using\n`require.resolve(\"LIBRARY_OR_REQUIRE_PATH\")` to get the appropriate installed\nfile path to a dependency.\n\nThis comes up in situations including:\n\n* Webpack loaders\n* Karma included files\n\nThe other thing that comes up in our Archetype configuration file is the\ngeneral _requirement_ that builder is running from the project root, not\nrelative to an archetype. However, some libraries / tools will interpret\n`\"./\"` as relative to the _configuration file_ which may be in an archetype.\n\nSo, for these instances and instances where you typically use `__dirname`,\nan archetype may need to use `process.cwd()` and be constrained to **only**\never running from the project root. Some scenarios where the `process.cwd()`\npath base is necessary include:\n\n* Webpack entry points, aliases\n* Karma included files (that cannot be `require.resolve`-ed)\n\n### Avoid npm Lifecycle Commands\n\nWe recommend _not_ using any of the special `npm` `scripts` commands listed in\nhttps://docs.npmjs.com/misc/scripts such as:\n\n* prepublish, postinstall\n* test\n* stop, start\n\nin your archetype `scripts`. This is due to the fact that the archetype\n`package.json` files are themselves consumed by `npm` for publishing (which\ncan lead to tasks executing for the _archetype_ instead of the project _using_\nthe archetype) and potentially lead to awkward recursive composed task\nscenarios.\n\nInstead, we recommend adding an `npm:<task>` prefix to your tasks to identify\nthem as usable in root projects for real `npm` lifecycle tasks.\n\nWe plan on issuing warnings for archetypes that do implement lifecycle tasks\nin: https://github.com/FormidableLabs/builder/issues/81\n\n### Other Process Execution\n\nThe execution of tasks generally must _originate_ from Builder, because of all\nof the environment enhancements it adds. So, for things that themselves exec\nor spawn processes, like `concurrently`, this can be a problem. Typically, you\nwill need to have the actual command line processes invoked _by_ Builder.\n\n### Terminal Color\n\nBuilder uses `exec` under the hood with piped `stdout` and `stderr`. Programs\ntypically interpret the piped environment as \"doesn't support color\" and\ndisable color. Consequently, you typically need to set a \"**force color**\"\noption on your executables in `scripts` commands if they exist.\n\n### Why Exec?\n\nSo, why `exec` and not `spawn` or something similar that has a lot more process\ncontrol and flexibility? The answer lies in the fact that most of what Builder\nconsumes is shell strings to execute, like `script --foo --bar \"Hi there\"`.\n_Parsing_ these arguments into something easily consumable by `spawn` and always\ncorrect is quite challenging. `exec` works easily with straight strings, and\nsince that is the target of `scripts` commands, that is what we use for Builder.\n\n### I Give Up. How Do I Abandon Builder?\n\nBuilder is designed to be as close to vanilla npm as possible. So, if for\nexample you were using the `builder-react-component` archetype with a project\n`package.json` like:\n\n```js\n\"scripts\": {\n  \"postinstall\": \"builder run npm:postinstall\",\n  \"preversion\": \"builder run npm:preversion\",\n  \"version\": \"builder run npm:version\",\n  \"test\": \"builder run npm:test\",\n  /* other deps */\n},\n\"dependencies\": {\n  \"builder\": \"v2.0.0\",\n  \"builder-react-component\": \"v0.0.5\",\n  /* other deps */\n},\n\"devDependencies\": {\n  \"builder-react-component-dev\": \"v0.0.5\",\n  /* other deps */\n}\n```\n\nand decided to _no longer_ use Builder, here is a rough set of steps to unpack\nthe archetype into your project and remove all Builder dependencies:\n\n* Copy all `ARCHETYPE/package.json:dependencies` to your\n  `PROJECT/package.json:dependencies` (e.g., from `builder-react-component`).\n  You _do not_ need to copy over `ARCHETYPE/package.json:devDependencies`.\n* Copy all `ARCHETYPE/package.json:scripts` to your\n  `PROJECT/package.json:scripts` that do not begin with the `builder:` prefix.\n  Remove the `npm:` prefix from any `scripts` tasks and note that you may have\n  to manually resolve tasks of the same name within the archetype and also with\n  your project.\n* Copy all `ARCHETYPE/package.json:config` variables to your\n  `PROJECT/package.json:config`.\n* Copy all `ARCHETYPE-dev/package.json:dependencies` to your\n  `PROJECT/package.json:devDependencies`\n  (e.g., from `builder-react-component-dev`)\n* Copy all configuration files used in your `ARCHETYPE` into the root project.\n  For example, for `builder-react-component` you would need to copy the\n  `builder-react-component/config` directory to `PROJECT/config` (or a renamed\n  directory).\n* Replace all instances of `require(\"<archetype-dev>/require\")` and\n  `require(\"<archetype>/require\")` with `require` in configuration / other\n  Node.js files from the archetype.\n* Review all of the combined `scripts` tasks and:\n    * resolve duplicate task names\n    * revise configuration file paths for the moved files\n    * replace instances of `builder run <task>` with `npm run <task>`\n    * for `builder concurrent <task1> <task2>` tasks, first install the\n      `concurrently` package and then rewrite to:\n      `concurrent 'npm run <task1>' 'npm run <task2>'`\n\n... and (with assuredly a few minor hiccups) that's about it! You are\nBuilder-free and back to a normal `npm`-controlled project.\n\n### Versions v1, v2, v3\n\nThe `builder` project effectively starts at `v2.x.x`. Prior to that Builder was\na small DOM utility that fell into disuse, so we re-purposed it for a new\nwonderful destiny! But, because we follow semver, that means everything starts\nat `v2` and as a helpful tip / warning:\n\n> Treat `v2.x` as a `v0.x` release\n\nWe'll try hard to keep it tight, but at our current velocity there are likely\nto be some bumps and API changes that won't adhere strictly to semver until\nthings settle down in `v3.x`-on.\n\n[builder-react-component]: https://github.com/FormidableLabs/builder-react-component\n[trav_img]: https://api.travis-ci.org/FormidableLabs/builder.svg\n[trav_site]: https://travis-ci.org/FormidableLabs/builder\n[cov]: https://coveralls.io\n[cov_img]: https://img.shields.io/coveralls/FormidableLabs/builder.svg\n[cov_site]: https://coveralls.io/r/FormidableLabs/builder\n",
  "readmeFilename": "README.md",
  "_id": "builder@2.10.1",
  "dist": {
    "shasum": "6c46366aa7527ddc9e7f3899ae02cd8e04d50d79"
  },
  "_from": "builder@",
  "_resolved": "https://registry.npmjs.org/builder/-/builder-2.10.1.tgz"
}
